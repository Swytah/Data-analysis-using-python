import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
#Pandas can easily read data stored in different file formats like CSV, JSON, XML or even Excel. Parsing always involves specifying the correct structure, encoding and other details. The `read_csv` method reads CSV files and accepts many parameters.
df = pd.read_csv('btc-market-price.csv')
print(df.head())
#The CSV file we're reading has only two columns: `timestamp` and `price`. It doesn't have a header, it contains whitespaces and has values separated by commas. pandas automatically assigned the first row of data as headers, which is incorrect. We can overwrite this behavior with the `header` parameter:
df = pd.read_csv('btc-market-price.csv', header=None)
print(df.head())
#We can then set the names of each column explicitely by setting the `df.columns` attribute:
df.columns = ['Timestamp', 'Price']
print(df.shape)
print(df.head())
print(df.tail(3))
#The type of the `Price` column was correctly interpreted as `float`, but the `Timestamp` was interpreted as a regular string (`object` in pandas notation):
print(df.dtypes)
#We can perform a vectorized operation to parse all the Timestamp values as `Datetime` objects:
print(pd.to_datetime(df['Timestamp']).head())
df['Timestamp'] = pd.to_datetime(df['Timestamp'])
print(df.head())
print(df.dtypes)
#The timestamp looks a lot like the index of this `DataFrame`: `date > price`. We can change the autoincremental ID generated by pandas and use the `Timestamp DS` column as the Index:
df.set_index('Timestamp', inplace=True)
print(df.head())
print(df.loc['2017-09-29'])

## Putting everything together

#And now, we've finally arrived to the final, desired version of the `DataFrame` parsed from our CSV file. The steps were:
df = pd.read_csv('btc-market-price.csv', header=None)
df.columns = ['Timestamp', 'Price']
df['Timestamp'] = pd.to_datetime(df['Timestamp'])
df.set_index('Timestamp', inplace=True)
print(df.head())
#**There should be a better way**. And there is . And there usually is, explicitly with all these repetitive tasks with pandas.

#The `read_csv` function is extremely powerful and you can specify many more parameters at import time. We can achive the same results with only one line by doing:
df = pd.read_csv(
    'btc-market-price.csv',
    header=None,
    names=['Timestamp', 'Price'],
    index_col=0,
    parse_dates=True
)
print(df.head())
print(df.loc['2017-09-29'])

## Plotting basics

#`pandas` integrates with Matplotlib and creating a plot is as simple as:
df.plot()
plt.show()
#Behind the scenes, it's using `matplotlib.pyplot`'s interface. We can create a similar plot with the `plt.plot()` function:
plt.plot(df.index, df['Price'])
plt.show()
#`plt.plot()` accepts many parameters, but the first two ones are the most important ones: the values for the `X` and `Y` axes. Another example:
x = np.arange(-10, 11)
plt.plot(x, x ** 2)
plt.show()
#We're using `matplotlib`'s global API, which is horrible but it's the most popular one. We'll learn later how to use the _OOP_ API which will make our work much easier.

plt.plot(x, -1 * (x ** 2))
plt.show()
#Each `plt` function alters the global state. If you want to set settings of your plot you can use the `plt.figure` function. Others like `plt.title` keep altering the global plot:
plt.figure(figsize=(12, 6))
plt.plot(x, x ** 2)
plt.plot(x, -1 * (x ** 2))

plt.title('My Nice Plot')
plt.show()
#Some of the arguments in `plt.figure` and `plt.plot` are available in the pandas' `plot` interface:
df.plot(figsize=(16, 9), title='Bitcoin Price 2017-2018')
plt.show()
## A more challenging parsing

#To demonstrate plotting two columns together, we'll try to add Ether prices to our `df` DataFrame. The ETH prices data can be found in the `data/eth-price.csv` file. The problem is that it seems like that CSV file was created by someone who really hated programmers. Take a look at it and see how ugly it looks like. We'll still use `pandas` to parse it.
eth = pd.read_csv('eth-price.csv')

print(eth.head())
#As you can see, it has a `Value` column (which represents the price), a `Date(UTC)` one that has a string representing dates and also a `UnixTimeStamp` date represeting the datetime in unix timestamp format. The header is read automatically, let's try to parse dates with the CSV Reader:
eth = pd.read_csv('eth-price.csv', parse_dates=True)

print(eth.dtypes)
print(eth.head())
#Seems like the `parse_dates` attribute didn't work. We'll need to add a little bit more customization. Let's divide this problem and focus on the problem of "date parsing" first. The simplest option would be to use the `UnixTimeStamp` column. The `pandas` module has a `to_datetime` function that converts Unix timestamps to Datetime objects automatically:
pd.to_datetime(eth['UnixTimeStamp']).head()
#The problem is the precision of unix timestamps. To match both columns we'll need to use the same index and, our `df` containing Bitcoin prices, is "per day":
print(df.head())
#We could either, remove the precision of `UnixTimeStamp` or attempt to parse the `Date(UTC)`. Let's do String parsing of `Date(UTC)` for fun:
print(pd.to_datetime(eth['Date(UTC)']).head())
#That seems to work fine! Why isn't it then parsing the `Date(UTC)` column? Simple, the `parse_dates=True` parameter will instruct pandas to parse the index of the `DataFrame`. If you want to parse any other column, you must explicitly pass the column position or name:
print(pd.read_csv('eth-price.csv', parse_dates=[0]).head())
#Putting everything together again:
eth = pd.read_csv('eth-price.csv', parse_dates=True, index_col=0)
print(eth.info())

print(eth.head())
#We can now combine both `DataFrame`s into one. Both have the same index, so aligning both prices will be easy. Let's first create an empty `DataFrame` and with the index from Bitcoin prices:
prices = pd.DataFrame(index=df.index)
print(prices.head())
#And we can now just set columns from the other `DataFrame`s:
prices['Bitcoin'] = df['Price']
prices['Ether'] = eth['Value']
print(prices.head())
#We can now try plotting both values:
prices.plot(figsize=(12, 6))
plt.show()
#seems like there's a tiny gap between Dec 2017 and Jan 2018. Let's zoom in there:
prices.loc['2017-12-01':'2018-01-01'].plot(figsize=(12, 6))
plt.show()























